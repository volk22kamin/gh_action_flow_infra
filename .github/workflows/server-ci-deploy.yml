name: Server CI + Deploy (ECS)

on:
  push:
    branches: [ main ]
    paths:
      - 'application_code/server/**'
      - '.github/workflows/server-ci-deploy.yml'
  pull_request:
    paths:
      - 'application_code/server/**'
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

concurrency:
  group: server-deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_DIR: application_code/server

jobs:
  ci:
    name: Build & Test & Scan
    runs-on: ubuntu-latest

    services:
      mongo:
        image: mongo:7
        ports:
          - 27017:27017
        env:
          MONGO_INITDB_ROOT_USERNAME: root
          MONGO_INITDB_ROOT_PASSWORD: rootpass
        options: >-
          --name gha-mongo
          --health-cmd="mongosh --eval 'db.adminCommand({ ping: 1 })'"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=12

    defaults:
      run:
        working-directory: ${{ env.APP_DIR }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: '${{ env.APP_DIR }}/package-lock.json'

      # Wait for Mongo to be healthy and export URI for tests
      - name: Wait for Mongo & set MONGODB_URI
        run: |
          set -euo pipefail
          # wait until the service is healthy
          for i in {1..60}; do
            STATUS=$(docker inspect --format='{{json .State.Health.Status}}' gha-mongo | tr -d '"')
            if [ "$STATUS" = "healthy" ]; then
              echo "MongoDB is healthy"
              break
            fi
            echo "Waiting for MongoDB... ($i/60)"
            sleep 2
          done
          # expose URI to the rest of the job (tests read this)
          echo "MONGODB_URI=mongodb://root:rootpass@127.0.0.1:27017/test?authSource=admin" >> $GITHUB_ENV

      - name: Install deps
        run: npm ci

      - name: Run tests
        env:
          # Optional: make sure your app actually uses this env
          MONGODB_URI: ${{ env.MONGODB_URI }}
        run: npm test --if-present

      - name: Build Docker image (local only)
        run: |
          echo "Building image for scanâ€¦"
          docker build -t local/server:ci .

      - name: Trivy scan (fail on HIGH,CRITICAL)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: 'local/server:ci'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'HIGH,CRITICAL'


  deploy:
    name: Push to ECR + Update ECS service
    needs: [ci]
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Compute image tags
        id: tags
        run: |
          IMAGE="${{ steps.ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY }}"
          SHA_TAG="${IMAGE}:${GITHUB_SHA::12}"
          LATEST_TAG="${IMAGE}:latest"
          echo "image=${IMAGE}"     >> $GITHUB_OUTPUT
          echo "sha=${SHA_TAG}"     >> $GITHUB_OUTPUT
          echo "latest=${LATEST_TAG}" >> $GITHUB_OUTPUT

      - name: Build & push image
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ steps.tags.outputs.sha }}
            ${{ steps.tags.outputs.latest }}

      # Render a new task definition from the LIVE service's current TD
      - name: Prepare new task definition (swap image)
        id: render
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}        # name or ARN
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}        # name or ARN
          CONTAINER_NAME: ${{ vars.CONTAINER_NAME }}  # e.g., nodejs-container
          NEW_IMAGE: ${{ steps.tags.outputs.sha }}    # full ECR URI:TAG from step above
        run: |
          set -euo pipefail

          TD_ARN=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" \
            --services "$ECS_SERVICE" \
            --query 'services[0].taskDefinition' \
            --output text)

          aws ecs describe-task-definition \
            --task-definition "$TD_ARN" \
            --query 'taskDefinition' --output json > td.json

          # Ensure target container exists
          jq -e --arg NAME "$CONTAINER_NAME" \
            'any(.containerDefinitions[]; .name == $NAME)' td.json >/dev/null || {
              echo "Container \"$CONTAINER_NAME\" not found in task definition"; exit 1;
            }

          # Strip ONLY read-only fields, keep valid config like ephemeralStorage/runtimePlatform/etc.
          jq '
            del(
              .taskDefinitionArn,
              .revision,
              .status,
              .registeredAt,
              .registeredBy,
              .requiresAttributes,
              .compatibilities
            )
          ' td.json \
          | jq --arg NAME "$CONTAINER_NAME" --arg IMG "$NEW_IMAGE" '
              .containerDefinitions = (
                .containerDefinitions | map(
                  if .name == $NAME then .image = $IMG | . else . end
                )
              )
            ' > rendered-taskdef.json

          NEW_TD_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://rendered-taskdef.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "td=$NEW_TD_ARN" >> "$GITHUB_OUTPUT"

      - name: Update service to new revision (bootstrap-safe)
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
          NEW_TD_ARN: ${{ steps.render.outputs.td }}
        run: |
          set -euo pipefail

          CUR=$(aws ecs describe-services \
            --cluster "$ECS_CLUSTER" --services "$ECS_SERVICE" \
            --query 'services[0].desiredCount' --output text)

          if [ "$CUR" = "0" ] || [ "$CUR" = "None" ]; then
            # First-ever promote from 0 -> 1
            aws ecs update-service \
              --cluster "$ECS_CLUSTER" \
              --service "$ECS_SERVICE" \
              --task-definition "$NEW_TD_ARN" \
              --desired-count 1 \
              --force-new-deployment
          else
            # Steady-state: update ONLY the task definition; preserve current count / autoscaling
            aws ecs update-service \
              --cluster "$ECS_CLUSTER" \
              --service "$ECS_SERVICE" \
              --task-definition "$NEW_TD_ARN" \
              --force-new-deployment
          fi

      - name: Wait for stability (and fail fast on placement errors)
        env:
          ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
          ECS_SERVICE: ${{ vars.ECS_SERVICE }}
        run: |
          set -euo pipefail
          # quick surfacing of common placement failures
          msg=$(aws ecs describe-services --cluster "$ECS_CLUSTER" --services "$ECS_SERVICE" \
            --query "services[0].events[?contains(message, 'unable to place a task')]|[0].message" --output text || true)
          if [ "$msg" != "None" ] && [ -n "$msg" ]; then
            echo "$msg"
            exit 1
          fi

          aws ecs wait services-stable --cluster "$ECS_CLUSTER" --services "$ECS_SERVICE"
